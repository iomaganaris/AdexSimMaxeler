package simulation;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

class SimulationKernel extends Kernel {

	private static final DFEType type = dfeInt(32);
	private static final DFEType double_type = dfeFloat(11,53);
	private static final DFEType long_type = dfeInt(80);

	protected SimulationKernel(KernelParameters parameters) {
		super(parameters);

		DFEVectorType<DFEVar> vectorVars =
			new DFEVectorType<DFEVar>(dfeFloat(11,53), 6); // The real size of the vector is 5 but the program would not compile

		DFEVectorType<DFEVar> SynapsesVector =
			new DFEVectorType<DFEVar>(dfeFloat(11,53), 12); // The real size of the vector is 11 but the program would not compile

		int loop2Length = 4;	// Same with manager

		OffsetExpr loopLength = stream.makeOffsetAutoLoop("loopLength");
		DFEVar loopLengthVal = loopLength.getDFEVar(this, dfeUInt(32));

		DFEVar N = io.scalarInput("N", dfeUInt(32));	// Number of Input Neurons
		DFEVar M_S = io.scalarInput("M_S", dfeUInt(32));	// Number of Adex Source Neurons
		DFEVar M_T = io.scalarInput("M_T", dfeUInt(32));	// Number of Adex Target Neurons
		DFEVar steps = io.scalarInput("Steps", dfeUInt(32));	// Steps of Simulation
		DFEVar totalBurstsX = io.scalarInput("totalBurstsX",dfeUInt(32));
		DFEVar wordsPerBurstX = io.scalarInput("wordsPerBurstX",dfeUInt(32));
		DFEVar totalBurstsSyn = io.scalarInput("totalBurstsSyn",dfeUInt(32));
		DFEVar wordsPerBurstSyn = io.scalarInput("wordsPerBurstSyn",dfeUInt(32));
		//debug.simPrintf("totalBurstsX = %d, wordsPerBurstX = %d, totalBurstsSyn = %d, wordsPerBurstSyn = %d, steps = %d\n", totalBurstsX, wordsPerBurstX, totalBurstsSyn, wordsPerBurstSyn, steps);

		int adex_params_size = 16; // for allignment
		int adex_params_addrBits = MathUtils.bitsToAddress(adex_params_size);

		int stdp_params_size = 32;
		int stdp_params_addrBits = MathUtils.bitsToAddress(stdp_params_size);

		Count.Params paramsOne = control.count.makeParams(stdp_params_addrBits+1)	// Counter up to 16 for saving the 16 values of adex params in FMEM
		.withMax(32)
		.withInc(1)
		.withWrapMode(WrapMode.STOP_AT_MAX);
		Counter counterOne = control.count.makeCounter(paramsOne);
		//counterOne.getCount().simWatch("counterOne");

		// Counters for reading Neurons and Synapses

		//First loop counters
		CounterChain chainA = control.count.makeCounterChain(counterOne.getCount()>31);
		DFEVar stepA = chainA.addCounter(steps,1);
		DFEVar loopA = chainA.addCounter(3,1);
		//stepA.simWatch("stepA");
		//loopA.simWatch("loopA");
		DFEVar burstCountA = chainA.addCounter(totalBurstsX,1);
		DFEVar wordCountA = chainA.addCounter(wordsPerBurstX,1);
		DFEVar tempA_1_max = M_S+N;
		DFEVar tempA_1 = chainA.addCounter(tempA_1_max,1);
		DFEVar tempA_2 = chainA.addCounter(/*loopLengthVal*/16,1);

		DFEVar n = tempA_1;
		DFEVar m = burstCountA*wordsPerBurstX + wordCountA;
		//n.simWatch("n");
		//m.simWatch("m");

		CounterChain chainB = control.count.makeCounterChain(counterOne.getCount()>31);
		DFEVar stepB = chainB.addCounter(steps,1);
		DFEVar loopB = chainB.addCounter(3,1);
		DFEVar burstCountB = chainB.addCounter(totalBurstsSyn,1);
		DFEVar wordCountB = chainB.addCounter(wordsPerBurstSyn,1);
		DFEVar tempB_1 = chainB.addCounter(/*loopLengthVal*/16,1);

		CounterChain chainSN = control.count.makeCounterChain(counterOne.getCount()>31 & loopA === 1 & n < M_S);
		DFEVar burstCountSN = chainSN.addCounter(totalBurstsX,1);
		DFEVar wordCountSN = chainSN.addCounter(wordsPerBurstX,1);
		DFEVar tempSN = chainSN.addCounter(16,1);
		//debug.simPrintf("stepA = %d, loopA = %d, stepB = %d, loopB = %d, n = %d, m = %d\n", stepA, loopA, stepB, loopB, n, m);

		DFEVar inputAddress = counterOne.getCount();

		DFEVar adex_in = inputAddress < adex_params_size;
		DFEVar stdp_in = inputAddress < stdp_params_size;
		DFEVar readingInput = adex_in | stdp_in;
		DFEVar adex_param_addr = inputAddress.cast(dfeUInt(adex_params_addrBits));
		DFEVar stdp_param_addr = inputAddress.cast(dfeUInt(stdp_params_addrBits));

		DFEVar adex_p_array = io.input("adex_params", double_type, adex_in);
		DFEVar stdp_p_array = io.input("stdp_params", double_type, stdp_in);

		// Saving adex parameters in FMEM
		Memory<DFEVar> adex_params = mem.alloc(dfeFloat(11,53), adex_params_size);
		adex_params.write(adex_param_addr, adex_p_array, adex_in);

		// Saving stdp parameters in FMEM
		Memory<DFEVar> stdp_params = mem.alloc(dfeFloat(11,53), stdp_params_size);
		stdp_params.write(stdp_param_addr, stdp_p_array, stdp_in);

		DFEVar adex_add = constant.var(1).cast(dfeUInt(adex_params_addrBits));
		DFEVar gL = adex_params.read(adex_add);
		adex_add = constant.var(3).cast(dfeUInt(adex_params_addrBits));
		DFEVar EL = adex_params.read(adex_add);
		adex_add = constant.var(4).cast(dfeUInt(adex_params_addrBits));
		DFEVar DeltaT = adex_params.read(adex_add);
		adex_add = constant.var(0).cast(dfeUInt(adex_params_addrBits));
		DFEVar C = adex_params.read(adex_add);
		adex_add = constant.var(6).cast(dfeUInt(adex_params_addrBits));
		DFEVar vtrest = adex_params.read(adex_add);
		adex_add = constant.var(8).cast(dfeUInt(adex_params_addrBits));
		DFEVar tauvt = adex_params.read(adex_add);
		adex_add = constant.var(10).cast(dfeUInt(adex_params_addrBits));
		DFEVar c = adex_params.read(adex_add);
		adex_add = constant.var(9).cast(dfeUInt(adex_params_addrBits));
		DFEVar tauw = adex_params.read(adex_add);
		adex_add = constant.var(12).cast(dfeUInt(adex_params_addrBits));
		DFEVar Vr = adex_params.read(adex_add);
		adex_add = constant.var(11).cast(dfeUInt(adex_params_addrBits));
		DFEVar b = adex_params.read(adex_add);
		adex_add = constant.var(7).cast(dfeUInt(adex_params_addrBits));
		DFEVar vtmax = adex_params.read(adex_add);
		adex_add = constant.var(13).cast(dfeUInt(adex_params_addrBits));
		DFEVar defaultclock_dt = adex_params.read(adex_add);


		DFEVar stdp_add = constant.var(21).cast(dfeUInt(stdp_params_addrBits));
		DFEVar tau_FFp = stdp_params.read(stdp_add);
		stdp_add = constant.var(17).cast(dfeUInt(stdp_params_addrBits));
		DFEVar tau_FBn = stdp_params.read(stdp_add);
		stdp_add = constant.var(14).cast(dfeUInt(stdp_params_addrBits));
		DFEVar tau_u = stdp_params.read(stdp_add);
		stdp_add = constant.var(19).cast(dfeUInt(stdp_params_addrBits));
		DFEVar tau_FBp = stdp_params.read(stdp_add);
		stdp_add = constant.var(15).cast(dfeUInt(stdp_params_addrBits));
		DFEVar tau_r = stdp_params.read(stdp_add);
		stdp_add = constant.var(4).cast(dfeUInt(stdp_params_addrBits));
		DFEVar s = stdp_params.read(stdp_add);
		stdp_add = constant.var(23).cast(dfeUInt(stdp_params_addrBits));
		DFEVar etaA = stdp_params.read(stdp_add);
		stdp_add = constant.var(22).cast(dfeUInt(stdp_params_addrBits));
		DFEVar etaU = stdp_params.read(stdp_add);
		stdp_add = constant.var(20).cast(dfeUInt(stdp_params_addrBits));
		DFEVar AFFp = stdp_params.read(stdp_add);
		stdp_add = constant.var(16).cast(dfeUInt(stdp_params_addrBits));
		DFEVar AFBn = stdp_params.read(stdp_add);
		stdp_add = constant.var(18).cast(dfeUInt(stdp_params_addrBits));
		DFEVar AFBp = stdp_params.read(stdp_add);
		stdp_add = constant.var(9).cast(dfeUInt(stdp_params_addrBits));
		DFEVar Umin = stdp_params.read(stdp_add);
		stdp_add = constant.var(8).cast(dfeUInt(stdp_params_addrBits));
		DFEVar Umax = stdp_params.read(stdp_add);
		stdp_add = constant.var(6).cast(dfeUInt(stdp_params_addrBits));
		DFEVar Amin = stdp_params.read(stdp_add);
		stdp_add = constant.var(5).cast(dfeUInt(stdp_params_addrBits));
		DFEVar Amax = stdp_params.read(stdp_add);

		DFEVar t = stepA.cast(double_type) * defaultclock_dt;
		//t.simWatch("t");
		DFEVar A_control = ~readingInput & (wordCountA === 0 & tempA_1 === 0 & tempA_2 === 0);
		//DFEVar burstCount_A = loopA === 0 ? burstCountA : burstCountA_2;
		DFEVar burstCount_A = burstCountA;
		LMemCommandStream.makeKernelOutput("XcmdStream",
				A_control,                 // control
				burstCount_A,                      // address (burstCount*burstSize)
				constant.var(dfeUInt(8), 1),      // size	(number of bursts per read)
				constant.var(dfeUInt(1), 0),      // inc	(inc in bursts of address)
				constant.var(dfeUInt(1), 0),      // stream
				constant.var(false));

		DFEVar A_control_out = ~readingInput & (wordCountA === 0 & tempA_1 === 0 & tempA_2 === 0 & loopA.neq(2));
		//DFEVar burstCount_A = loopA === 0 ? burstCountA : burstCountA_2;
		DFEVar burstCount_A_out = burstCountA;
		LMemCommandStream.makeKernelOutput("XOutcmdStream",
				A_control_out,                 // control
				burstCount_A_out,                      // address (burstCount*burstSize)
				constant.var(dfeUInt(8), 1),      // size	(number of bursts per read)
				constant.var(dfeUInt(1), 0),      // inc	(inc in bursts of address)
				constant.var(dfeUInt(1), 0),      // stream
				constant.var(false)/*loopA === 1 & burstCount_A_out === (totalBurstsX - 1) & stepA === steps-1*/);

		DFEVar B_control = ~readingInput & (wordCountB === 0 & tempB_1 === 0 & loopB !== 0);
		DFEVar burstCount_B = burstCountB;
		LMemCommandStream.makeKernelOutput("SynIncmdStream",
				B_control,                 // control
				totalBurstsX + burstCount_B,        // address
				constant.var(dfeUInt(8), 1),      // size
				constant.var(dfeUInt(1), 0),      // inc
				constant.var(dfeUInt(1), 0),      // stream
				constant.var(false));

		DFEVar B_control_o = ~readingInput & (wordCountB === 0 & tempB_1 === 0 & loopB !== 0);
		LMemCommandStream.makeKernelOutput("SynOutcmdStream",
				B_control_o,                  // control
				totalBurstsX + burstCount_B,     // address
				constant.var(dfeUInt(8), 1),       // size
				constant.var(dfeUInt(1), 0),       // inc
				constant.var(dfeUInt(1), 0),       // stream
				/*constant.var(false)*/loopB === 2 & burstCount_B === (totalBurstsSyn - 1) & stepB === steps-1 & tempB_1 === 0);

		DFEVar SN_control = ~readingInput & (wordCountSN === 0 & tempSN === 0 & loopA === 1 & n < M_S);
		//DFEVar burstCount_A = loopA === 0 ? burstCountA : burstCountA_2;
		DFEVar burstCount_SN = burstCountSN;
		LMemCommandStream.makeKernelOutput("SNcmdStream",
				SN_control,                 // control
				burstCount_SN,                      // address (burstCount*burstSize)
				constant.var(dfeUInt(8), 1),      // size	(number of bursts per read)
				constant.var(dfeUInt(1), 0),      // inc	(inc in bursts of address)
				constant.var(dfeUInt(1), 0),      // stream
				constant.var(false));

		DFEVector<DFEVar> syn = io.input("SynIn", SynapsesVector, ~readingInput & (loopB !== 0 & tempB_1 === 0));
		DFEVector<DFEVar> x = io.input("X", vectorVars, ~readingInput & tempA_1 === 0 & tempA_2 === 0);
		DFEVector<DFEVar> x_copy = x;
		//x_copy[0].simWatch("vt");
		//syn[6].simWatch("u_in");
		// **************** SOLVE NEURONS START **************** //
		DFEVar vt = x[0];
		DFEVar vm = x[1];
		DFEVar I = x[2];
		DFEVar x_var = x[3];
		DFEVar Spike = x[4];
		// Calculations
		DFEVar _vm, _vt, _x;
		_vm = (gL*(EL-vm)+gL*DeltaT*KernelMath.exp((vm-vt)/DeltaT)+I-x_var)/C;
		_vt = -(vt-vtrest)/tauvt;
		//vtrest.simWatch("vtrest");
		//tauvt.simWatch("tauvt");
		//_vt.simWatch("vt_c");
		_x = (c*(vm-EL)-x_var)/tauw;
		DFEVar vm_o = vm + _vm * defaultclock_dt;
        DFEVar vt_o = vt + _vt * defaultclock_dt;
        DFEVar x_o = x_var + _x * defaultclock_dt;
        DFEVar I_o = I;	// I must be read from memory in every timestep
        DFEVar Spike_o = Spike;

        DFEVar control = vm_o > vt;
        //control.simWatch("control");

        vm_o = control ? Vr : vm_o;
        x_o = control ? x_o + b : x_o;
        vt_o = control ? vtmax : vt_o;
		Spike_o = control ? constant.var(1).cast(double_type) : constant.var(0).cast(double_type);


		DFEVector<DFEVar> x_o_arr = vectorVars.newInstance(this);

		x_o_arr[0] <== vt_o;
		x_o_arr[1] <== vm_o;
		x_o_arr[2] <== I_o;
		x_o_arr[3] <== x_o;
		x_o_arr[4] <== Spike_o;
		x_o_arr[5] <== Spike_o;

		//x_o_arr.simWatch("x_o_arr");
		// ************* SOLVE NEURONS END ****************** //

		// ********** UPDATE SYNAPSES PRE START ************* //
		DFEVar InputSpike = io.input("InputSpikes", dfeInt(32), ~readingInput /*& step === 0*/ & loopA === 1 & n >= M_S & m === 0 & tempA_2 === 0);
		// Saving Input Spikes in FMEM
		int max_N = 1000;
		int max_N_bits = MathUtils.bitsToAddress(max_N);

		DFEVar InputSpikeAddr = n.cast(dfeUInt(max_N_bits));
		Memory<DFEVar> InputSpikes = mem.alloc(type, max_N);
		InputSpikes.write(InputSpikeAddr, InputSpike, m === 0 & loopA === 1);

		DFEVar spike = (m === 0) ? InputSpike : InputSpikes.read(InputSpikeAddr);

		DFEVector<DFEVar> SourceNeuron = io.input("SourceNeurons", vectorVars, ~readingInput /*& step === 0*/ & loopA === 1 & tempSN === 0 & n < M_S);
		//SourceNeuron.simWatch("sourceneuron");

		DFEVar FFp = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? syn[2] * KernelMath.exp(-(-syn[9] + t)/tau_FFp) : syn[2];
		DFEVar FBn = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? syn[4] * KernelMath.exp(-(-syn[9] + t)/tau_FBn) : syn[4];
		DFEVar control_pre = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1;
		//control_pre.simWatch("control_pre");
		DFEVar u = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? syn[7] + (-syn[7] + syn[6]) * KernelMath.exp(-(-syn[9] + t)/tau_u) : syn[6];
		//u.simWatch("u");
		DFEVar FBp = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? syn[3] * KernelMath.exp(-(-syn[9] + t)/tau_FBp) : syn[3];
		DFEVar R = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? (syn[5] - 1) * KernelMath.exp(-(-syn[9] + t)/tau_r) + 1 : syn[5];
		DFEVar targetI = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? s * syn[8] * R * u : syn[10];
		//targetI.simWatch("targetI");
		DFEVar U = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? syn[7] + etaU * (-AFBn * FBn * FBp + AFBp * FBp * FFp) : syn[7];
		U = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 & (U < Umin) ? Umin : U;	// Needs conditions
		U = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 & (U > Umax) ? Umax : U;	// Needs conditions
		DFEVar w = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? U * syn[8] : syn[1];
		FFp = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? FFp + 1 : FFp;				// Needs conditions
		R = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? R - R * u : R;				// Needs conditions
		u = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? u + U * (1-u) : u;			// Needs conditions
		//u.simWatch("u");
		DFEVar lastupdate = ((n<M_S & SourceNeuron[4] === 1) | (n >= M_S & spike === 1)) & syn[0] === 1 ? t : syn[9];

		DFEVector<DFEVar> x_t = vectorVars.newInstance(this);
		DFEVector<DFEVar> x_tt = vectorVars.newInstance(this);
		DFEVector<DFEVar> x_out_p = vectorVars.newInstance(this);

		x_t = n === 0 ? x_copy : stream.offset(x_out_p,-16/*loopLength*/);
		//x_t[2].simWatch("x_t_I");
		//x_tt = loop_counter === 0 ? x_t : x_tt;
		x_out_p[0] <== x_t[0];
		x_out_p[1] <== x_t[1];
		x_out_p[2] <== (syn[0] === 1 & ((n < M_S & SourceNeuron[4] === 1) | (n>= M_S & spike === 1))) ? targetI : x_t[2];
		//x_out_p[2].simWatch("x_o_I");
		x_out_p[3] <== x_t[3];
		x_out_p[4] <== x_t[4];
		x_out_p[5] <== x_t[5];
		//x_out_p[2].simWatch("xO_i");
		//x_t[2].simWatch("xT_i");

		DFEVector<DFEVar> syn_o_p = SynapsesVector.newInstance(this);
		syn_o_p[0] <== syn[0];
		syn_o_p[1] <== w;
		syn_o_p[2] <== FFp;
		syn_o_p[3] <== FBp;
		syn_o_p[4] <== FBn;
		syn_o_p[5] <== R;
		syn_o_p[6] <== u;
		syn_o_p[7] <== U;
		syn_o_p[8] <== syn[8];
		syn_o_p[9] <== lastupdate;
		syn_o_p[10] <== targetI;
		syn_o_p[11] <== syn[11];
		// ********** UPDATE SYNAPSES PRE END ************** //

		// ********** UPDATE SYNAPSES POST START *********** //

		// loop = 0 calculations
		DFEVar FFp_po = x[4] === 1 & syn[0] === 1 & loopA === 1 ? syn_o_p[2] * KernelMath.exp(-(-syn_o_p[9] + t)/tau_FFp) : syn_o_p[2];
		DFEVar FBn_po = x[4] === 1 & syn[0] === 1 & loopA === 1 ? syn_o_p[4] * KernelMath.exp(-(-syn_o_p[9] + t)/tau_FBn) : syn_o_p[4];
		DFEVar u_po = x[4] === 1 & syn[0] === 1 & loopA === 1 ? syn_o_p[7] + (-syn_o_p[7] + syn_o_p[6]) * KernelMath.exp(-(-syn_o_p[9] + t)/tau_u) : syn_o_p[6];
//		u.cast(double_type).simWatch("u");
		DFEVar FBp_po = x[4] === 1 & syn[0] === 1 & loopA === 1 ? syn_o_p[3] * KernelMath.exp(-(-syn_o_p[9] + t)/tau_FBp) : syn_o_p[3];
		DFEVar R_po = x[4] === 1 & syn[0] === 1 & loopA === 1 ? (syn_o_p[5] - 1) * KernelMath.exp(-(-syn_o_p[9] + t)/tau_r) + 1 : syn_o_p[5];
		DFEVar A_po = x[4] === 1 & syn[0] === 1 & loopA === 1 ? syn_o_p[8] + etaA * (AFFp * FFp_po * FBn_po) : syn_o_p[8];
		// loop = 0 calculations finish

		DFEVector<DFEVar> syn_o_po = SynapsesVector.newInstance(this);
		syn_o_po[0] <== syn[0];
		syn_o_po[1] <== w;
		syn_o_po[2] <== FFp_po;
		syn_o_po[3] <== FBp_po;
		syn_o_po[4] <== FBn_po;
		syn_o_po[5] <== R_po;
		syn_o_po[6] <== u_po;
		syn_o_po[7] <== U;
		syn_o_po[8] <== A_po;
		syn_o_po[9] <== lastupdate;
		syn_o_po[10] <== targetI;
		syn_o_po[11] <== syn[11];

		// Mean calculation part
		DFEVar carriedSum = double_type.newInstance(this);
		DFEVar carriedNum = double_type.newInstance(this);

		DFEVar sum_t = m === 0 & n === 0 & loopA === 1 ? constant.var(0) : carriedSum;
		DFEVar num_t = m === 0 & n === 0 & loopA === 1 ? constant.var(0) : carriedNum;

		sum_t = x[4] === 1 & syn[0] === 1 & loopA === 1 ? sum_t + AFFp * FFp_po * FBn_po : sum_t;
		//FFp_po.simWatch("FFp_po");
		//FBn_po.simWatch("FBn_po");
		//sum_t.simWatch("sum_t");
		num_t = x[4] === 1 & syn[0] === 1 & loopA === 1 ? num_t + 1 : num_t;
		carriedSum <== stream.offset(sum_t, -16/*loopLength*/);
		carriedNum <== stream.offset(num_t, -16/*loopLength*/);
		DFEVar mean_t = sum_t/num_t;
		//mean_t.simWatch("mean_t");
		DFEVar mean_fin = loopA === 2 ? mean_t : constant.var(0);
		//mean_fin.simWatch("mean_fin");
		// Mean calculation part finish

		// loop = 1 calculations
		DFEVar temp = etaA * 0.5 * mean_fin;
		DFEVar A_po_1 = x[4] === 1 & syn[0] === 1 & loopA === 2 ? syn[8] - temp : syn[8];
		//A_1.simWatch("A_1");
		DFEVar A_po_t = A_po_1 < Amin & x[4] === 1 & syn[0] === 1 & loopA === 2 ? Amin : A_po_1;
		//A_t.simWatch("A_t");
		DFEVar A_po_tt = A_po_t > Amax & x[4] === 1 & syn[0] === 1 & loopA === 2 ? Amax : A_po_t;
		//A_tt.simWatch("A_tt");
		DFEVar w_po =  x[4] === 1 & syn[0] === 1 & loopA === 2 ? syn[7] * A_po_tt : syn[1];
		DFEVar FBp_po_1 =  x[4] === 1 & syn[0] === 1 & loopA === 2 ? syn[3] + 1 : syn[3];
		DFEVar FBn_po_1 =  x[4] === 1 & syn[0] === 1 & loopA === 2 ? syn[4] + 1 : syn[4];
		DFEVar lastupdate_po = x[4] === 1 & syn[0] === 1 & loopA === 2 ? t : syn[9];
		// loop = 1 calculations finish

		// Connecting Output
		//DFEVar FBp_fin = loopA === 1 ? FBp_po : FBp_po_1;
		//DFEVar FBn_fin = loopA === 1 ? FBn_po : FBn_po_1;
		//DFEVar A_fin = loopA === 1 ? A_po : A_po_tt;
//		A_fin.cast(double_type).simWatch("A_fin");
		DFEVector<DFEVar> syn_o = SynapsesVector.newInstance(this);

		syn_o[0] <== syn[0];
		syn_o[1] <== w_po;
		syn_o[2] <== syn[2];
		syn_o[3] <== FBp_po_1;
		syn_o[4] <== FBn_po_1;
		syn_o[5] <== syn[5];
		syn_o[6] <== syn[6];
		//syn[6].simWatch("syn_6");
		//syn_o[6].simWatch("syn_o_6");
		syn_o[7] <== syn[7];
		syn_o[8] <== A_po_tt;
		syn_o[9] <== lastupdate_po;
		syn_o[10] <== syn[10];
		syn_o[11] <== syn[11];

		// ********** UPDATE SYNAPSES POST END ************* //
		DFEVector<DFEVar> x_out = loopA === 0 ? x_o_arr : x_out_p;
		//x_out[2].simWatch("x_out_I");
		DFEVar x_control_out = ~readingInput & ((loopA === 0 & tempA_1 === 0) | (loopA === 1 & tempA_1 === tempA_1_max-1)) & tempA_2 === 15;
		//x_control_out.simWatch("x_control_out");
		io.output("XOut", x_out, vectorVars, x_control_out);
		DFEVector<DFEVar> syn_out = loopB === 1 ? syn_o_po : syn_o;
		DFEVar syn_o_control = ~readingInput & (tempB_1 === 15/*loopLengthVal-1*/ & loopB.neq(0));
		//syn_o_control.simWatch("syn_o_control");
		io.output("SynOut", syn_out, SynapsesVector, syn_o_control);
	}

}
